package com.richodemus.autoplaylist

import io.github.vjames19.futures.jdk8.Future
import io.github.vjames19.futures.jdk8.flatMap
import io.github.vjames19.futures.jdk8.map
import java.util.concurrent.CompletableFuture

private val rToken = RefreshToken("enter-a-refresh-token")

fun main_rename_to_just_main(args: Array<String>) {
    val validToken = refreshToken(rToken).map { it.accessToken }

    validToken.map { println("Token: $it") }

    val artist = "Gloryhammer"

    val tracksFutures = getTracks(validToken, artist)


    val tracks = tracksFutures.join()
    println()
    println("Tracks:")
    tracks.forEach { println("\t" + it) }

    val trackUris = tracks.map { it.uri }


    val accessToken = validToken.join()


    val createPlaylistAndAddTracksFuture = createPlaylist(
            accessToken,
            UserId("richodemus"),
            artist,
            "autogenerated",
            false)
            .map { it.id }
            .map { playListId ->
                println("playlist id: $playListId")
                val chunks = trackUris.chunked(100)
                chunks.map {
                    addTracks(accessToken, UserId("richodemus"), playListId, it)
                }
            }.flatMap { futures ->
                Future {
                    futures.map { it.join() }
                }
            }


    val snapshotIds = createPlaylistAndAddTracksFuture.join()

    println("Done, snapshot id is: $snapshotIds")
}

private fun getTracks(validToken: CompletableFuture<AccessToken>, artist: String): CompletableFuture<List<Track>> {
    return validToken.flatMap {
        findArtist(it, artist).map { artist -> Pair(it, artist) }
    }.map {
        println(it.second)
        Pair(it.first, it.second.first())
    }.flatMap {
        getAlbums(it.first, it.second.id).map { albums -> Pair(it.first, albums) }
    }.map {
        println("Albums:")
        it.second.forEach { println("\t" + it) }
        it.second.filterNot { it.album_group == "appears_on" }.map { album -> getTracks(it.first, album.id) }
    }.flatMap { futures ->
        Future {
            futures.map { it.join() }
        }
    }.map {
        it.flatMap { it }
    }
}